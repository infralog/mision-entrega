<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Misi√≥n Entrega: El Juego del Camioncito</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Previene zoom y scroll en la p√°gina entera */
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 500px;
            max-height: 500px;
            border: 2px solid #334155;
            position: relative;
            overflow: hidden;
            background-color: #f3e9d2; /* Color base cremita */
        }
        .grid-cell {
            width: 100%;
            height: 100%;
        }
        .street {
            background-color: #6b7280; /* Color de la calle gris oscuro */
            position: relative; /* Necesario para las l√≠neas */
        }
        .grass {
             background-color: #f3e9d2; /* Color cremita */
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: clamp(1rem, 3.5vw, 1.5rem);
        }
        /* Estilo para las l√≠neas horizontales */
        .street-horizontal::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 4%; /* Grosor de la l√≠nea */
            background: repeating-linear-gradient(
                to right,
                #f3e9d2, /* Color de la l√≠nea */
                #f3e9d2 40%, /* Largo del trazo */
                transparent 40%,
                transparent 100% /* Espacio */
            );
            background-size: 25% 100%;
            transform: translateY(-50%);
        }
        /* Estilo para las l√≠neas verticales */
        .street-vertical::before {
            content: "";
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 4%; /* Grosor de la l√≠nea */
            background: repeating-linear-gradient(
                to bottom,
                #f3e9d2, /* Color de la l√≠nea */
                #f3e9d2 40%, /* Largo del trazo */
                transparent 40%,
                transparent 100% /* Espacio */
            );
            background-size: 100% 25%;
            transform: translateX(-50%);
        }
        .game-object {
            width: calc(100% / 12);
            height: calc(100% / 12);
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            transition: top 0.2s ease-out, left 0.2s ease-out;
            will-change: top, left;
            z-index: 10;
        }
        #truck .package-on-board {
            position: absolute;
            top: -50%;
            font-size: 0.8em;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #truck.has-package .package-on-board {
            opacity: 1;
        }
        #message-box {
            transition: opacity 0.5s, transform 0.5s;
            z-index: 20;
        }
        #joystick-container {
            width: 120px;
            height: 120px;
            position: relative;
        }
        #joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        #joystick-knob {
            width: 60px;
            height: 60px;
            background-color: #3b82f6;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 p-4 pt-4">

    <main class="w-full max-w-5xl mx-auto flex flex-col items-center">
        
        <div class="w-full max-w-lg text-center mb-4">
            <!-- Row 1: Logo + Title -->
            <div class="flex items-center justify-center gap-2">
                <div class="w-12 flex-shrink-0">
                    <svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg" aria-label="Infralog Logo">
                        <circle cx="50" cy="25" r="22" fill="#38bdf8"></circle>
                        <circle cx="50" cy="25" r="9" fill="white"></circle>
                        <rect x="25" y="50" width="50" height="10" fill="#3f3354" rx="2"></rect>
                    </svg>
                </div>
                <h1 class="text-xl font-bold text-[#3f3354] text-left">Misi√≥n Entrega</h1>
            </div>

            <!-- Row 2: Counters -->
            <div class="flex justify-center gap-2 mt-2">
                <div id="timer-container" class="bg-white p-1 rounded-lg shadow-md text-center w-20 cursor-pointer hover:bg-slate-100 transition-colors">
                    <h2 class="text-xs font-semibold text-slate-500">TIEMPO</h2>
                    <p id="timer" class="text-xl font-bold text-red-600">20</p>
                </div>
                <div class="bg-white p-1 rounded-lg shadow-md text-center w-20">
                    <h2 class="text-xs font-semibold text-slate-500">ENTREGAS</h2>
                    <p id="score" class="text-xl font-bold text-blue-600">0</p>
                </div>
            </div>
            <p class="text-slate-600 mt-2 text-center">Recoge el paquete üì¶ y ll√©valo a la casa üè†.</p>
        </div>

        <div class="flex flex-col items-center justify-center gap-4 w-full">
            <!-- Game Board -->
            <div id="game-container" class="relative flex-shrink-0">
                <div id="game-board" class="game-board rounded-lg shadow-lg">
                    <!-- El mapa y los objetos se inyectar√°n aqu√≠ -->
                </div>
                <div id="message-box" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white p-4 rounded-lg opacity-0 pointer-events-none transform scale-110">
                    <div id="message-text" class="text-4xl font-bold text-center"></div>
                </div>
            </div>

            <!-- Joystick Controls -->
            <div id="joystick-container" class="mt-4">
                <div id="joystick-base"></div>
                <div id="joystick-knob"></div>
            </div>
        </div>
    </main>

    <script>
        // Game elements
        const gameContainer = document.getElementById('game-container');
        const board = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const timerContainer = document.getElementById('timer-container');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');

        // Game settings
        const gridSize = 12;
        const trafficCarCount = 5;
        const timeOptions = [20, 30, 40];
        let currentTimeIndex = 0;
        let TOTAL_TIME = timeOptions[currentTimeIndex];
        let score = 0;
        let timeLeft = TOTAL_TIME;
        let gameActive = false;
        let firstMoveMade = false;
        let map = [];
        let traffic = [];
        let gameLoopInterval = null;
        let timerInterval = null;

        // Game state
        let truck = { x: 0, y: 0, element: null, hasPackage: false };
        let packageObj = { x: 0, y: 0, element: null };
        let house = { x: 0, y: 0, element: null };
        let warehouse = { x: 0, y: 0, element: null };

        // --- Map Generation ---
        function generateMap() {
            map = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            for (let i = 2; i < gridSize; i += 3) {
                for (let y = 0; y < gridSize; y++) map[y][i] = 1;
                for (let x = 0; x < gridSize; x++) map[i][x] = 1;
            }
        }

        function drawMap() {
            board.innerHTML = '';
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    if (map[y][x] === 1) {
                        cell.classList.add('street');
                        const isHorizontal = y % 3 === 2;
                        const isVertical = x % 3 === 2;
                        if (isHorizontal) cell.classList.add('street-horizontal');
                        if (isVertical) cell.classList.add('street-vertical');
                    } else {
                        cell.classList.add('grass');
                        if (Math.random() < 0.25) cell.innerHTML = 'üå≥';
                    }
                    board.appendChild(cell);
                }
            }
        }

        // --- Game Initialization ---
        function createGameObject(emoji, id) {
            const el = document.createElement('div');
            if (id) el.id = id;
            el.classList.add('game-object');
            el.innerHTML = emoji;
            board.appendChild(el);
            return el;
        }

        function startNewGame() {
            const oldButton = gameContainer.querySelector('button');
            if (oldButton) oldButton.remove();

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            
            score = 0;
            timeLeft = TOTAL_TIME;
            updateScore();
            updateTimerDisplay();

            loadLevel();
        }

        function loadLevel() {
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            generateMap();
            drawMap();
            
            truck.element = createGameObject('üöö<span class="package-on-board">üì¶</span>', 'truck');
            packageObj.element = createGameObject('üì¶', 'package');
            house.element = createGameObject('üè†', 'house');
            warehouse.element = createGameObject('üè¢', 'warehouse');
            
            truck.hasPackage = false;
            firstMoveMade = false;
            
            placeObjectsForNewRound();
            
            render();
            gameLoopInterval = setInterval(gameLoop, 400); 
        }

        // --- Object Placement ---
        function getRandomStreetPosition() {
            let x, y;
            do {
                x = Math.floor(Math.random() * gridSize);
                y = Math.floor(Math.random() * gridSize);
            } while (map[y][x] !== 1);
            return { x, y };
        }

        function isSamePosition(pos1, pos2) {
            return pos1.x === pos2.x && pos1.y === pos2.y;
        }

        function getManhattanDistance(pos1, pos2) {
            return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
        }

        function placeObjectsForNewRound() {
            const occupiedPositions = [];

            const warehousePos = getRandomStreetPosition();
            occupiedPositions.push(warehousePos);
            warehouse.x = warehousePos.x; warehouse.y = warehousePos.y;
            packageObj.x = warehouse.x; packageObj.y = warehouse.y;

            let housePos;
            do {
                housePos = getRandomStreetPosition();
            } while (
                isSamePosition(housePos, warehousePos) ||
                getManhattanDistance(housePos, warehousePos) < 4 ||
                housePos.x === warehousePos.x || housePos.y === warehousePos.y
            );
            occupiedPositions.push(housePos);
            house.x = housePos.x; house.y = housePos.y;

            let farthestPos = null;
            let maxDist = -1;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (map[y][x] === 1) {
                        const currentPos = {x, y};
                        if (!occupiedPositions.some(p => isSamePosition(p, currentPos))) {
                            const dist = getManhattanDistance(currentPos, warehousePos);
                            if (dist > maxDist) {
                                maxDist = dist;
                                farthestPos = currentPos;
                            }
                        }
                    }
                }
            }
            const truckPos = farthestPos;
            occupiedPositions.push(truckPos);
            truck.x = truckPos.x; truck.y = truckPos.y;
            
            packageObj.element.style.display = 'block';
            truck.element.classList.remove('has-package');
            truck.hasPackage = false;

            traffic = [];
            for (let i = 0; i < trafficCarCount; i++) {
                let carPos;
                do {
                    carPos = getRandomStreetPosition();
                } while (occupiedPositions.some(p => isSamePosition(p, carPos)));
                occupiedPositions.push(carPos);
                
                const carElement = createGameObject('üöó', null);
                traffic.push({ ...carPos, element: carElement, dx: 0, dy: 0 });
            }
        }

        // --- Rendering ---
        function render() {
            const updatePosition = (obj) => {
                const sizePercentage = 100 / gridSize;
                obj.element.style.top = `${obj.y * sizePercentage}%`;
                obj.element.style.left = `${obj.x * sizePercentage}%`;
            };
            if(truck.element) updatePosition(truck);
            if(packageObj.element) updatePosition(packageObj);
            if(house.element) updatePosition(house);
            if(warehouse.element) updatePosition(warehouse);
            traffic.forEach(updatePosition);
        }

        // --- Game Logic & Loop ---
        let isMoving = false;
        function moveTruck(dx, dy) {
            if (isMoving) return;

            if (!gameActive && !timerInterval) {
                gameActive = true;
                timerInterval = setInterval(updateTimer, 1000);
            }
            if (!gameActive) return;

            const newX = truck.x + dx;
            const newY = truck.y + dy;
            if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && map[newY][newX] === 1) {
                if (!firstMoveMade) firstMoveMade = true;
                truck.x = newX;
                truck.y = newY;
                isMoving = true;
                setTimeout(() => { isMoving = false; }, 200); // Cooldown to match transition
                checkCollisions();
                render();
            }
        }

        function moveTraffic() {
            traffic.forEach(car => {
                const possibleMoves = [];
                const allDirections = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

                allDirections.forEach(dir => {
                    const nextX = car.x + dir.dx;
                    const nextY = car.y + dir.dy;
                    const isNotReversing = !(dir.dx === -car.dx && dir.dy === -car.dy);
                    if (nextX >= 0 && nextX < gridSize && nextY >= 0 && nextY < gridSize && map[nextY][nextX] === 1 && isNotReversing) {
                        possibleMoves.push(dir);
                    }
                });

                let nextMove;
                if (possibleMoves.length === 0) {
                    nextMove = { dx: -car.dx, dy: -car.dy };
                } else {
                    nextMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }

                car.dx = nextMove.dx;
                car.dy = nextMove.dy;
                car.x += car.dx;
                car.y += car.dy;
            });
        }

        function gameLoop() {
            if (!gameActive) return;
            moveTraffic();
            checkCollisions();
            render();
        }

        function checkCollisions() {
            if (!gameActive) return;

            if (!truck.hasPackage && isSamePosition(truck, warehouse)) {
                truck.hasPackage = true;
                truck.element.classList.add('has-package');
                packageObj.element.style.display = 'none';
                showMessage('¬°Paquete recogido!', 500);
            }

            if (truck.hasPackage && isSamePosition(truck, house)) {
                score++;
                updateScore();
                loadLevel();
            }
            
            if (firstMoveMade) {
                for (const car of traffic) {
                    if (isSamePosition(truck, car)) {
                        showMessage('¬°Choque!', 500);
                        loadLevel();
                        return;
                    }
                }
            }
        }
        
        function updateTimer() {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameLoopInterval);
            clearInterval(timerInterval);
            timerInterval = null;
            showMessage(`¬°Tiempo! Entregas: ${score}`, 3000);
            
            const playAgainButton = document.createElement('button');
            playAgainButton.textContent = 'Jugar de Nuevo';
            playAgainButton.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-purple-600 text-white font-bold py-4 px-8 rounded-lg shadow-lg z-30 hover:bg-purple-700 transition-colors';
            playAgainButton.addEventListener('click', startNewGame);
            gameContainer.appendChild(playAgainButton);
        }

        function updateScore() {
            scoreElement.textContent = score;
        }
        
        function updateTimerDisplay() {
            timerElement.textContent = timeLeft;
        }

        function showMessage(text, duration) {
            messageText.textContent = text;
            messageBox.style.opacity = '1';
            messageBox.style.transform = 'scale(1)';
            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.transform = 'scale(1.1)';
            }, duration);
        }

        function changeTime() {
            if (gameActive || timerInterval) return;
            currentTimeIndex = (currentTimeIndex + 1) % timeOptions.length;
            TOTAL_TIME = timeOptions[currentTimeIndex];
            timeLeft = TOTAL_TIME;
            updateTimerDisplay();
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':    case 'w': e.preventDefault(); moveTruck(0, -1); break;
                case 'ArrowDown':  case 's': e.preventDefault(); moveTruck(0, 1);  break;
                case 'ArrowLeft':  case 'a': e.preventDefault(); moveTruck(-1, 0); break;
                case 'ArrowRight': case 'd': e.preventDefault(); moveTruck(1, 0);  break;
            }
        });

        timerContainer.addEventListener('click', changeTime);
        
        // --- Joystick Controls Logic ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joystickStartX, joystickStartY;
        const baseRect = joystickContainer.getBoundingClientRect();
        const baseRadius = baseRect.width / 2;
        const knobRadius = joystickKnob.getBoundingClientRect().width / 2;
        const maxKnobOffset = baseRadius - knobRadius;

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            let dx = touch.clientX - joystickStartX;
            let dy = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > maxKnobOffset) {
                dx = (dx / distance) * maxKnobOffset;
                dy = (dy / distance) * maxKnobOffset;
            }
            
            joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
            
            const angle = Math.atan2(dy, dx);
            const threshold = 0.5; // Deadzone

            if (distance > baseRadius * 0.2) { // Only move if joystick is pushed enough
                 if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) moveTruck(1, 0);
                    else moveTruck(-1, 0);
                } else {
                    if (dy > 0) moveTruck(0, 1);
                    else moveTruck(0, -1);
                }
            }
        }
        
        joystickContainer.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const rect = joystickContainer.getBoundingClientRect();
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
            joystickActive = true;
            handleJoystickMove(e);
        }, { passive: false });

        joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });

        joystickContainer.addEventListener('touchend', () => {
            joystickActive = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        });


        // --- Initial Load ---
        loadLevel();
        showMessage('¬°Mueve el cami√≥n para empezar!', 2000);
    </script>
</body>
</html>