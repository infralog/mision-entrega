<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Misión Entrega: El Juego del Camioncito</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Previene zoom y scroll en la página entera */
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 500px;
            max-height: 500px;
            border: 2px solid #334155;
            position: relative;
            overflow: hidden;
            background-color: #a7f3d0; /* Color base verde claro */
        }
        .grid-cell {
            width: 100%;
            height: 100%;
        }
        .street {
            background-color: #6b7280; /* Color de la calle gris oscuro */
            position: relative; /* Necesario para las líneas */
        }
        .grass {
             background-color: #a7f3d0; /* Color verde claro */
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: clamp(1rem, 3.5vw, 1.5rem);
        }
        /* Estilo para las líneas horizontales */
        .street-horizontal::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 4%; /* Grosor de la línea */
            background: repeating-linear-gradient(
                to right,
                #f3e9d2, /* Color de la línea */
                #f3e9d2 40%, /* Largo del trazo */
                transparent 40%,
                transparent 100% /* Espacio */
            );
            background-size: 25% 100%;
            transform: translateY(-50%);
        }
        /* Estilo para las líneas verticales */
        .street-vertical::before {
            content: "";
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 4%; /* Grosor de la línea */
            background: repeating-linear-gradient(
                to bottom,
                #f3e9d2, /* Color de la línea */
                #f3e9d2 40%, /* Largo del trazo */
                transparent 40%,
                transparent 100% /* Espacio */
            );
            background-size: 100% 25%;
            transform: translateX(-50%);
        }
        .game-object {
            width: calc(100% / 12);
            height: calc(100% / 12);
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            /* Transición más rápida para mayor fluidez */
            transition: top 0.15s ease-out, left 0.15s ease-out;
            will-change: top, left;
            z-index: 10;
        }
        #truck .package-on-board {
            position: absolute;
            top: -50%;
            font-size: 0.8em;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #truck.has-package .package-on-board {
            opacity: 1;
        }
        #message-box {
            transition: opacity 0.5s, transform 0.5s;
            z-index: 20;
        }
        #joystick-container {
            width: 120px;
            height: 120px;
            position: relative;
        }
        #joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        #joystick-knob {
            width: 60px;
            height: 60px;
            background-color: #3b82f6;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 p-4 pt-4">

    <main class="w-full max-w-5xl mx-auto flex flex-col items-center">
        
        <div class="w-full max-w-lg text-center mb-4">
            <!-- Row 1: Logo + Title -->
            <div class="flex items-center justify-center gap-2">
                <div class="w-12 flex-shrink-0">
                    <svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg" aria-label="Infralog Logo">
                        <circle cx="50" cy="25" r="22" fill="#38bdf8"></circle>
                        <circle cx="50" cy="25" r="9" fill="white"></circle>
                        <rect x="25" y="50" width="50" height="10" fill="#3f3354" rx="2"></rect>
                    </svg>
                </div>
                <h1 class="text-xl font-bold text-[#3f3354] text-left">Misión Entrega</h1>
            </div>

            <!-- Row 2: Counters -->
            <div class="flex justify-center gap-2 mt-2">
                <div id="timer-container" class="bg-white p-1 rounded-lg shadow-md text-center w-20 cursor-pointer hover:bg-slate-100 transition-colors">
                    <h2 class="text-xs font-semibold text-slate-500">TIEMPO</h2>
                    <p id="timer" class="text-xl font-bold text-red-600">20</p>
                </div>
                <div class="bg-white p-1 rounded-lg shadow-md text-center w-20">
                    <h2 class="text-xs font-semibold text-slate-500">ENTREGAS</h2>
                    <p id="score" class="text-xl font-bold text-blue-600">0</p>
                </div>
                <div id="difficulty-container" class="bg-white p-1 rounded-lg shadow-md text-center w-20 cursor-pointer hover:bg-slate-100 transition-colors">
                    <h2 class="text-xs font-semibold text-slate-500">DIFICULTAD</h2>
                    <p id="difficulty" class="text-xl font-bold text-red-600">Alto</p>
                </div>
            </div>
            <p class="text-slate-600 mt-2 text-center">Recoge el paquete 📦 y llévalo a la casa 🏠.</p>
        </div>

        <div class="flex flex-col items-center justify-center gap-4 w-full">
            <!-- Game Board -->
            <div id="game-container" class="relative flex-shrink-0">
                <div id="game-board" class="game-board rounded-lg shadow-lg">
                    <!-- El mapa y los objetos se inyectarán aquí -->
                </div>
                <div id="message-box" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white p-4 rounded-lg opacity-0 pointer-events-none transform scale-110">
                    <div id="message-text" class="text-4xl font-bold text-center"></div>
                </div>
            </div>

            <!-- Joystick Controls -->
            <div id="joystick-container" class="mt-4">
                <div id="joystick-base"></div>
                <div id="joystick-knob"></div>
            </div>
        </div>
    </main>

    <script>
        // Game elements
        const gameContainer = document.getElementById('game-container');
        const board = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const timerContainer = document.getElementById('timer-container');
        const difficultyContainer = document.getElementById('difficulty-container');
        const difficultyElement = document.getElementById('difficulty');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');

        // Game settings
        const gridSize = 12;
        const trafficCarCount = 5;
        const timeOptions = [20, 30, 40];
        const difficultyLevels = [
            { name: 'Bajo', speed: 800, color: 'text-green-600' },
            { name: 'Medio', speed: 600, color: 'text-orange-500' },
            { name: 'Alto', speed: 400, color: 'text-red-600' }
        ];
        let currentDifficultyIndex = 2; // Start at Alto
        let currentTimeIndex = 0;
        let TOTAL_TIME = timeOptions[currentTimeIndex];
        let score = 0;
        let timeLeft = TOTAL_TIME;
        let gameActive = false;
        let firstMoveMade = false;
        let map = [];
        let traffic = [];
        let gameLoopInterval = null;
        let timerInterval = null;

        // Game state
        let truck = { x: 0, y: 0, element: null, hasPackage: false, justWrapped: false };
        let packageObj = { x: 0, y: 0, element: null };
        let house = { x: 0, y: 0, element: null };
        let warehouse = { x: 0, y: 0, element: null };

        // --- Map Generation ---
        function generateMap() {
            map = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            for (let i = 2; i < gridSize; i += 3) {
                for (let y = 0; y < gridSize; y++) map[y][i] = 1;
                for (let x = 0; x < gridSize; x++) map[i][x] = 1;
            }
        }

        function drawMap() {
            board.innerHTML = '';
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    if (map[y][x] === 1) {
                        cell.classList.add('street');
                        const isHorizontal = y % 3 === 2;
                        const isVertical = x % 3 === 2;
                        if (isHorizontal) cell.classList.add('street-horizontal');
                        if (isVertical) cell.classList.add('street-vertical');
                    } else {
                        cell.classList.add('grass');
                        const randomContent = Math.random();
                        if (randomContent < 0.15) {
                            cell.innerHTML = '🏡';
                        } else if (randomContent < 0.30) {
                            cell.innerHTML = '🌳';
                        }
                    }
                    board.appendChild(cell);
                }
            }
        }

        // --- Game Initialization ---
        function createGameObject(emoji, id) {
            const el = document.createElement('div');
            if (id) el.id = id;
            el.classList.add('game-object');
            el.innerHTML = emoji;
            board.appendChild(el);
            return el;
        }

        function startNewGame() {
            const oldButton = gameContainer.querySelector('button');
            if (oldButton) oldButton.remove();

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
            
            score = 0;
            timeLeft = TOTAL_TIME;
            updateScore();
            updateTimerDisplay();

            loadLevel();
        }

        function loadLevel() {
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            generateMap();
            drawMap();
            
            truck.element = createGameObject('🚚<span class="package-on-board">📦</span>', 'truck');
            packageObj.element = createGameObject('📦', 'package');
            house.element = createGameObject('🏠', 'house');
            warehouse.element = createGameObject('🏢', 'warehouse');
            
            truck.hasPackage = false;
            firstMoveMade = false;
            
            placeObjectsForNewRound();
            
            render();
            const currentDifficulty = difficultyLevels[currentDifficultyIndex];
            gameLoopInterval = setInterval(gameLoop, currentDifficulty.speed); 
        }

        // --- Object Placement ---
        function getRandomStreetPosition() {
            let x, y;
            do {
                x = Math.floor(Math.random() * gridSize);
                y = Math.floor(Math.random() * gridSize);
            } while (map[y][x] !== 1);
            return { x, y };
        }

        function isSamePosition(pos1, pos2) {
            return pos1.x === pos2.x && pos1.y === pos2.y;
        }

        function getManhattanDistance(pos1, pos2) {
            return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
        }

        function placeObjectsForNewRound() {
            const occupiedPositions = [];

            const warehousePos = getRandomStreetPosition();
            occupiedPositions.push(warehousePos);
            warehouse.x = warehousePos.x; warehouse.y = warehousePos.y;
            packageObj.x = warehouse.x; packageObj.y = warehouse.y;

            let housePos;
            do {
                housePos = getRandomStreetPosition();
            } while (
                isSamePosition(housePos, warehousePos) ||
                getManhattanDistance(housePos, warehousePos) < 4 ||
                housePos.x === warehousePos.x || housePos.y === warehousePos.y
            );
            occupiedPositions.push(housePos);
            house.x = housePos.x; house.y = housePos.y;

            let farthestPos = null;
            let maxDist = -1;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (map[y][x] === 1) {
                        const currentPos = {x, y};
                        if (!occupiedPositions.some(p => isSamePosition(p, currentPos))) {
                            const dist = getManhattanDistance(currentPos, warehousePos);
                            if (dist > maxDist) {
                                maxDist = dist;
                                farthestPos = currentPos;
                            }
                        }
                    }
                }
            }
            const truckPos = farthestPos;
            occupiedPositions.push(truckPos);
            truck.x = truckPos.x; truck.y = truckPos.y;
            
            packageObj.element.style.display = 'block';
            truck.element.classList.remove('has-package');
            truck.hasPackage = false;

            traffic = [];
            for (let i = 0; i < trafficCarCount; i++) {
                let carPos;
                do {
                    carPos = getRandomStreetPosition();
                } while (occupiedPositions.some(p => isSamePosition(p, carPos)));
                occupiedPositions.push(carPos);
                
                const carElement = createGameObject('🚗', null);
                traffic.push({ ...carPos, element: carElement, dx: 0, dy: 0, justWrapped: false });
            }
        }

        // --- Rendering ---
        function render() {
            const updatePosition = (obj) => {
                if (!obj.element) return;
                const sizePercentage = 100 / gridSize;

                if (obj.justWrapped) {
                    obj.element.style.transition = 'none';
                }

                obj.element.style.top = `${obj.y * sizePercentage}%`;
                obj.element.style.left = `${obj.x * sizePercentage}%`;

                if (obj.justWrapped) {
                    obj.element.offsetHeight; // Force reflow
                    obj.element.style.transition = '';
                    obj.justWrapped = false;
                }
            };
            updatePosition(truck);
            updatePosition(packageObj);
            updatePosition(house);
            updatePosition(warehouse);
            traffic.forEach(updatePosition);
        }

        // --- Game Logic & Loop ---
        let isMoving = false;
        
        function isAtIntersection(x, y) {
            let streetNeighbors = 0;
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            for (const [dx, dy] of directions) {
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                if (map[ny][nx] === 1) {
                    streetNeighbors++;
                }
            }
            return streetNeighbors > 2;
        }

        function moveTruck(dx, dy) {
            if (isMoving) return;

            if (!gameActive && !timerInterval) {
                gameActive = true;
                timerInterval = setInterval(updateTimer, 1000);
            }
            if (!gameActive) return;
            
            const currentX = truck.x;
            const currentY = truck.y;
            const newX = (currentX + dx + gridSize) % gridSize;
            const newY = (currentY + dy + gridSize) % gridSize;

            if (map[newY][newX] === 1) {
                if (!firstMoveMade) firstMoveMade = true;
                isMoving = true;
                
                const atIntersection = isAtIntersection(truck.x, truck.y);
                const cooldown = atIntersection ? 250 : 150;
                
                truck.justWrapped = (newX !== currentX + dx || newY !== currentY + dy);
                
                truck.x = newX;
                truck.y = newY;
                
                setTimeout(() => { isMoving = false; }, cooldown);
                checkCollisions();
                render();
            }
        }

        function moveTraffic() {
            traffic.forEach(car => {
                const originalX = car.x;
                const originalY = car.y;

                if (car.dx === 0 && car.dy === 0) {
                    const directions = [{dx: 0, dy: 1}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: -1, dy: 0}];
                    const validDirections = directions.filter(dir => map[(originalY + dir.dy + gridSize) % gridSize][(originalX + dir.dx + gridSize) % gridSize] === 1);
                    if(validDirections.length > 0) {
                        const newDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
                        car.dx = newDirection.dx;
                        car.dy = newDirection.dy;
                    }
                }
                
                const straightX = originalX + car.dx;
                const straightY = originalY + car.dy;
                const wrappedStraightX = (straightX + gridSize) % gridSize;
                const wrappedStraightY = (straightY + gridSize) % gridSize;

                if (map[wrappedStraightY][wrappedStraightX] !== 1 || (isAtIntersection(originalX, originalY) && Math.random() < 0.5)) {
                    const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
                    const possibleTurns = directions.filter(dir => !(dir.dx === -car.dx && dir.dy === -car.dy));
                    const validTurns = possibleTurns.filter(dir => map[(originalY + dir.dy + gridSize) % gridSize][(originalX + dir.dx + gridSize) % gridSize] === 1);

                    if (validTurns.length > 0) {
                        const turn = validTurns[Math.floor(Math.random() * validTurns.length)];
                        car.dx = turn.dx;
                        car.dy = turn.dy;
                    } else {
                        car.dx = -car.dx;
                        car.dy = -car.dy;
                    }
                }
                
                const finalX = originalX + car.dx;
                const finalY = originalY + car.dy;
                
                car.justWrapped = finalX < 0 || finalX >= gridSize || finalY < 0 || finalY >= gridSize;
                
                car.x = (finalX + gridSize) % gridSize;
                car.y = (finalY + gridSize) % gridSize;
            });
        }

        function gameLoop() {
            if (!gameActive) return;
            moveTraffic();
            checkCollisions();
            render();
        }

        function checkCollisions() {
            if (!gameActive) return;

            if (!truck.hasPackage && isSamePosition(truck, warehouse)) {
                truck.hasPackage = true;
                truck.element.classList.add('has-package');
                packageObj.element.style.display = 'none';
                showMessage('¡Paquete recogido!', 500);
            }

            if (truck.hasPackage && isSamePosition(truck, house)) {
                score++;
                updateScore();
                loadLevel();
            }
            
            if (firstMoveMade) {
                for (const car of traffic) {
                    if (isSamePosition(truck, car)) {
                        showMessage('¡Choque!', 500);
                        loadLevel();
                        return;
                    }
                }
            }
        }
        
        function updateTimer() {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameLoopInterval);
            clearInterval(timerInterval);
            timerInterval = null;
            showMessage(`¡Tiempo! Entregas: ${score}`, 3000);
            
            const playAgainButton = document.createElement('button');
            playAgainButton.textContent = 'Jugar de Nuevo';
            playAgainButton.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-purple-600 text-white font-bold py-4 px-8 rounded-lg shadow-lg z-30 hover:bg-purple-700 transition-colors';
            playAgainButton.addEventListener('click', startNewGame);
            gameContainer.appendChild(playAgainButton);
        }

        function updateScore() {
            scoreElement.textContent = score;
        }
        
        function updateTimerDisplay() {
            timerElement.textContent = timeLeft;
        }

        function showMessage(text, duration) {
            messageText.textContent = text;
            messageBox.style.opacity = '1';
            messageBox.style.transform = 'scale(1)';
            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.transform = 'scale(1.1)';
            }, duration);
        }

        function changeTime() {
            if (gameActive || timerInterval) return;
            currentTimeIndex = (currentTimeIndex + 1) % timeOptions.length;
            TOTAL_TIME = timeOptions[currentTimeIndex];
            timeLeft = TOTAL_TIME;
            updateTimerDisplay();
        }

        function changeDifficulty() {
            if (gameActive || timerInterval) return;
            
            difficultyElement.classList.remove(difficultyLevels[currentDifficultyIndex].color);
            currentDifficultyIndex = (currentDifficultyIndex + 1) % difficultyLevels.length;
            const newDifficulty = difficultyLevels[currentDifficultyIndex];
            difficultyElement.textContent = newDifficulty.name;
            difficultyElement.classList.add(newDifficulty.color);
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':    case 'w': e.preventDefault(); moveTruck(0, -1); break;
                case 'ArrowDown':  case 's': e.preventDefault(); moveTruck(0, 1);  break;
                case 'ArrowLeft':  case 'a': e.preventDefault(); moveTruck(-1, 0); break;
                case 'ArrowRight': case 'd': e.preventDefault(); moveTruck(1, 0);  break;
            }
        });

        timerContainer.addEventListener('click', changeTime);
        difficultyContainer.addEventListener('click', changeDifficulty);
        
        // --- Joystick Controls Logic (Improved for Responsiveness) ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joystickInitialX, joystickInitialY;
        const baseRect = joystickContainer.getBoundingClientRect();
        const baseRadius = baseRect.width / 2;
        const knobRadius = joystickKnob.getBoundingClientRect().width / 2;
        const maxKnobOffset = baseRadius - knobRadius;

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            
            // Calculate movement delta from the initial touch point for accuracy
            let dx = touch.clientX - joystickInitialX;
            let dy = touch.clientY - joystickInitialY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Clamp the visual knob's position to stay within the base
            let knobX = dx;
            let knobY = dy;
            if (distance > maxKnobOffset) {
                knobX = (dx / distance) * maxKnobOffset;
                knobY = (dy / distance) * maxKnobOffset;
            }
            
            joystickKnob.style.transform = `translate(-50%, -50%) translate(${knobX}px, ${knobY}px)`;
            
            // Determine direction based on the full, unclamped delta for responsiveness
            const deadzone = 20; // A 20px deadzone before movement registers
            if (distance > deadzone) {
                 if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) moveTruck(1, 0);
                    else moveTruck(-1, 0);
                } else {
                    if (dy > 0) moveTruck(0, 1);
                    else moveTruck(0, -1);
                }
            }
        }
        
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            // The reference point is the finger's starting position, not the center of the joystick
            joystickInitialX = touch.clientX;
            joystickInitialY = touch.clientY;
            joystickActive = true;
        }, { passive: false });

        joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });

        joystickContainer.addEventListener('touchend', () => {
            joystickActive = false;
            // Reset the knob to the center visually
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        });

        // --- Initial Load ---
        loadLevel();
        showMessage('¡Mueve el camión para empezar!', 2000);
    </script>
</body>
</html>

